package kr.co.thinkup.exsample.SocketSingletone.socket;import android.os.AsyncTask;import android.util.Log;import java.io.IOException;import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;import java.util.concurrent.Executor;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;/** * 2019-05-22 create by CHOI * https://github.com/claudiomarpda/ChatGroupAndroidClient */public class SocketConnect implements SocketConnection {    private static final String TAG = "SocketConnect";    private AsyncResponse           asyncResponse;    private Semaphore               sendSemaphore;//    private Semaphore               connectionSemaphore;    private SocketConnectTask       socketConnectTask;    private static SocketConnect    singleton;    private SocketConnect(String ipAddress, int port, AsyncResponse asyncResponse/*, Semaphore connectionSemaphore*/) throws IOException {        // semaphore for message sending synchronizing        sendSemaphore = new Semaphore(0);        // semaphore used by main thread to check if chatConnectioin is ok//        this.connectionSemaphore = connectionSemaphore;        // connects to the external main server system for sending and receiving        socketConnectTask = new SocketConnectTask(ipAddress, port);        socketConnectTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);        // reference for UI updating from the caller class        this.asyncResponse = asyncResponse;    }    public static SocketConnect connect(String ipAddress, int port, AsyncResponse asyncResponse/*, Semaphore connectionSemaphore*/) throws IOException {        if(singleton == null) {            singleton = new SocketConnect(ipAddress, port, asyncResponse/*, connectionSemaphore*/);        }        return singleton;    }    public void changeAsyncResponse(AsyncResponse asyncResponse) {        this.asyncResponse = asyncResponse;    }    @Override    public boolean isConnected() {        if(socketConnectTask == null) return false;        return socketConnectTask.isConnected();    }    @Override    public void disconnect() {        if(socketConnectTask != null) {            socketConnectTask.disconnect();            singleton = null;        }    }    /**     * Sends message to the server trough SocketConnect  and MessageSender     * @param message     */    public void sendMessage(byte[] message) {        if(socketConnectTask!= null && isConnected())           socketConnectTask.sendMessage(message);    }    /**     * SocketConnectTask thread initiates the MessageSender, MessageReceiver and its connections and streams.     */    private class SocketConnectTask extends AsyncTask<String, Void, String> implements SocketConnection {        private static final String SUCCESS = "SUCCESS";        private static final String FAIL = "FAIL";        private Socket              iSocket;        private SocketSender        socketSender;        private SocketReceiver      socketReceiver;        private String              connectionResult;        private String              ipAddress;        private int                 port;        private int                 timeout;        public SocketConnectTask(String ipAddress, int port) {            this.ipAddress = ipAddress;            this.port = port;            this.timeout = 8000;        }        @Override        protected String doInBackground(String... strings) {            try {                SocketAddress socketAddress = new InetSocketAddress(ipAddress, port);                this.iSocket = new Socket();                this.iSocket.connect(socketAddress, timeout);                socketSender = new SocketSender(iSocket, sendSemaphore);                socketReceiver = new SocketReceiver(iSocket, asyncResponse);//                socketSender = new SocketSender(ipAddress, port, sendSemaphore, timeout);//                socketReceiver = new SocketReceiver(ipAddress, port, asyncResponse, timeout);                this.publishProgress();                connectionResult = SUCCESS;            }catch (IOException e) {                Log.e(TAG, "doInBackground: ", e);                singleton = null;                connectionResult = e.getMessage();            }finally {//                connectionSemaphore.availablePermits();                Log.d(TAG, "doInBackground: finally ===============================================================================");//                connectionSemaphore.release();            }            return "ERROR";        }        @Override        protected void onProgressUpdate(Void... values) {            // Excutor is necessary to run more than on thread            Executor executor = Executors.newFixedThreadPool(2);//            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {//                wifiReceiverTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);//            }else {//                // runs sender thread//                socketSender.executeOnExecutor(executor);////                // runs receiver thread//                socketReceiver.executeOnExecutor(executor);//            }            // runs sender thread            socketSender.executeOnExecutor(executor);            // runs receiver thread            socketReceiver.executeOnExecutor(executor);        }        @Override        protected void onPostExecute(String s) {            asyncResponse.showConnectionResult(connectionResult);        }        @Override        public void disconnect() {            if(socketSender != null) {                socketSender.cancel(true);                socketSender.disconnect();                socketSender = null;            }            if(socketReceiver != null) {                socketReceiver.cancel(true);                socketReceiver.disconnect();                socketReceiver = null;            }        }        @Override        public boolean isConnected() {            if(socketSender != null && socketReceiver != null) {                return socketSender.isConnected() && socketReceiver.isConnected();            }            return false;        }        void sendMessage(byte[] message) {            socketSender.setMessage(message);//            sendSemaphore.release();        }    }}